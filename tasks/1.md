# 统一 AI 开发任务管理器（Web）项目计划文档 v0.1

## 1. 背景与目标

你希望用一个**网页**作为唯一入口，统一管理“把任务交给 AI CLI 工具执行”的全过程，避免手动进入各环境命令行调用 Claude Code / Codex CLI。系统需覆盖：

* 本机（Windows）开发与控制
* 多个远程服务器 / 远程容器（通过在目标环境部署 Runner 接入）
* 多项目并行：**同一项目目录串行**，不同项目目录/不同容器可并行
* 额度（Quota）监控：分别监控 **Claude Code 账户** 与 **OpenAI/Codex 账户**，并按账户聚合展示（不同机器/容器登录不同本地用户也要汇总到同一账户维度）
* **不做自动切换策略**：额度用完则停止继续调度，并在日志/状态中清晰呈现

---

## 2. 核心定义（必须对齐）

### 2.1 执行单元

* **Task（任务）**：一条待 AI 执行的工作（含 prompt、目标项目目录、选择的后端工具等）
* **Workspace（项目目录）**：一个“代码工作目录”的抽象（本机/远程/容器里某个 repo 路径）。**串行约束以 Workspace 为粒度**
* **Runner（执行节点）**：部署在某个环境（本机/远程机/容器）的轻量进程，负责本地创建工作区（可选 worktree）并用 CLI 跑任务，把日志/结果回传 Controller
* **Controller（控制面）**：运行 Web UI + API + 调度器 + 存储，统一下发任务、展示状态、聚合额度

### 2.2 并发/串行规则（关键）

* 对每个 `workspace_id`：任意时刻最多一个任务处于 `RUNNING`
* 全局可并行：不同 `workspace_id` 可同时 RUNNING（可配置全局上限，例如最多 K 个并发）

---

## 3. 范围与优先级（重新排序后的实现顺序）

### P0（优先完成：立刻可用、可见、能替代命令行）

1. **Web 作为唯一入口**

* 新增任务（选择：workspace + backend）
* 看板视图（TODO / RUNNING / DONE / FAILED / CANCELLED）
* 任务详情页：实时日志、退出码、错误分类

2. **分布式接入（Runner 模式）**

* Runner 注册/心跳
* Controller 显示在线节点、节点能力（支持哪些 backend、可用的 workspace 列表）

3. **按 Workspace 串行的调度器**

* 选择可运行任务（TODO 且 workspace 未占用）
* 下发给有该 workspace 的 runner 执行
* `RUNNING` 任务有 lease（防 runner 崩溃卡死）

### P1（第二优先：额度监控与“用完就停”）

4. **额度事件识别 + 聚合**

* Codex：从 `codex exec --json` 事件流中提取 usage（token 等）并记录（文档示例在 `turn.completed` 事件里包含 `usage`）。([OpenAI Developers][1])
* Claude：尽量从 `claude -p --output-format stream-json` 的结构化输出/或本地 transcript 中提取 token/cost（若拿不到则先做 best-effort 记账：执行次数、时长、错误事件）。Claude Code 提供 print mode `-p` 与 `--output-format`，以及可用字段里包含 `cost.total_cost_usd`、token 统计等（至少在 session 数据层面存在）。([Claude Code][2])

5. **额度耗尽则停止调度（不自动切换）**

* 识别“额度/限额”类错误 → 标记任务 `FAILED_QUOTA`
* 置 backend/account 状态为 `QUOTA_EXHAUSTED`（需要人工解除/等待恢复）
* 调度器对该 backend/account：暂停继续派发，并在 Web 顶部显著提示

### P2（后置：吞吐与工程流水线）

* Git worktree 并行化（你未来可能要，但现在先不引入冲突复杂度）
* 自动 merge/rebase/test/冲突处理 SOP 自动化
* 任务依赖 DAG（支持你真正安全并行的基础）

---

## 4. 技术选型（Windows 开发 + 多环境执行）

### 4.1 Controller（Windows 上运行）

* **语言/框架**：Python + FastAPI（API + SSE 日志流 + 简单服务都顺）
* **存储**：SQLite（个人内网 + 控制面单点，足够；后续可平滑换 Postgres）
* **前端**：优先“能跑起来、手机可用”

  * 推荐：FastAPI + Jinja2 + HTMX（不需要复杂前端工程也能做看板交互）
  * 若你追求更像截图那样体验：Next.js（可作为 P1.5 再做，不影响后端）

### 4.2 Runner（部署在本机/远程机/容器）

* **语言**：Python（跨平台；Windows/Linux/容器都一致）
* **职责**：拉取任务 → 在指定 workspace 执行 CLI → 流式回传日志 → 上报结果/usage

### 4.3 通信

* Controller ⇄ Runner：HTTP/JSON + **SSE**（或 Runner 反向推送日志到 Controller）
* 认证：内网个人用，最小做法是一个 shared token（Header）+ Controller 绑定内网地址

---

## 5. CLI 后端适配（必须基于真实参数）

### 5.1 Claude Code（非交互执行）

* 使用 **print mode**：`claude -p ...`（文档示例广泛使用 `-p` 配合输出格式）。([Claude Code][2])
* 结构化输出：`--output-format stream-json|json|text`（print mode 支持）。([Claude Code][2])
* 权限跳过：`--dangerously-skip-permissions` 存在。([Claude Code][2])
* 规划：Runner 以“非交互+可解析”为目标，默认用 `stream-json`，将 stdout 作为事件流；若失败回退到 text 并保留全量日志。

> 注意：Claude 侧 token/cost 的可提取性以实际输出为准；设计上允许“提取不到也不阻塞任务管理”，先保证闭环。

### 5.2 Codex CLI（非交互执行）

* 使用 `codex exec`（非交互模式官方推荐）。([OpenAI Developers][1])
* 机器可读输出：`codex exec --json` 输出 JSONL 事件流，并在 `turn.completed` 提供 `usage` 字段示例。([OpenAI Developers][1])
* 权限/沙箱：默认只读；需要写入时可用 `--full-auto` 或 `--sandbox danger-full-access`（按你的环境风险控制选择）。([OpenAI Developers][1])

---

## 6. 数据模型（SQLite 表/或等价 JSON 结构）

### 6.1 tasks

* `id`
* `title`
* `prompt`
* `workspace_id`
* `backend` ∈ {`claude_code`, `codex_cli`}
* `status` ∈ {`TODO`, `RUNNING`, `DONE`, `FAILED`, `FAILED_QUOTA`, `CANCELLED`}
* `created_at`, `updated_at`
* `run_id`（当前执行关联）

### 6.2 workspaces

* `workspace_id`
* `runner_id`（该 workspace 归属/可执行的 runner；允许多个 runner 声明同一路径则需额外约束）
* `path`（实际目录）
* `display_name`
* `concurrency_limit`（默认 1）

### 6.3 runners

* `runner_id`
* `env`（host/容器标识）
* `capabilities`（支持哪些 backend）
* `heartbeat_at`
* `max_parallel`（runner 自身并发上限）

### 6.4 runs（一次任务执行记录）

* `run_id`, `task_id`
* `runner_id`, `backend`
* `started_at`, `ended_at`
* `exit_code`
* `error_class`（`CODE`, `TOOL`, `NETWORK`, `QUOTA`, `UNKNOWN`）
* `log_path` / `log_blob`
* `usage_json`（Codex 可直接落 usage；Claude best-effort）

### 6.5 quota_state（按账户维度）

* `provider` ∈ {`claude`, `openai`}
* `account_label`（手工配置：例如 `main`；用于聚合）
* `state` ∈ {`OK`, `QUOTA_EXHAUSTED`, `UNKNOWN`}
* `last_event_at`
* `note`（例如最近一次 quota 错误摘要）

> account_label：因为不同环境的本地登录身份不一致，但你关心的是“归属到同一个账户”的汇总视图；用配置把 runner/backend 映射到该 label。

---

## 7. 调度器设计（按 Workspace 串行 + 全局并行）

每次调度 tick：

1. 找到所有 `TODO` 任务，按创建时间/优先级排序
2. 过滤掉：

   * `workspace_id` 当前已有 `RUNNING`
   * 对应 backend/account 处于 `QUOTA_EXHAUSTED`
3. 为剩余任务选择 runner（必须拥有该 workspace 且 backend 可用）
4. 创建 `run` 记录，task → `RUNNING`，设置 `lease_until = now + T`
5. runner 执行过程中续租（更新 lease_until）；超时则回收：task → `TODO` 并记录一次失败原因（runner失联）

---

## 8. Web 产品形态（你现在需要的“可见部分”）

* 顶栏：全局告警（quota exhausted、runner 离线）
* 看板：按状态列展示任务卡片
* 新建任务：文本输入 + 下拉选择 workspace + backend
* 任务详情：日志流（SSE）、运行元信息、重试/取消
* Runner 页：在线节点、心跳、当前任务、最近错误
* Quota 页：Claude/OpenAI 两个账户的状态与最近事件；使用量趋势（若可提取）

---

## 9. 里程碑（建议拆解）

### M1（P0，先跑通闭环）

* Controller：FastAPI + SQLite + 基础看板 + 新建任务
* Runner：注册/心跳 + 执行一个本地 workspace 的任务（先固定一个 backend）
* 日志：SSE 实时输出 + 任务完成写回 DONE/FAILED

### M2（P0 完整）

* 多 workspace + 多 runner
* workspace 串行约束生效（同项目不并行）
* lease/回收机制

### M3（P1：额度监控与停机）

* Codex：接入 `codex exec --json` 解析 usage 并落库([OpenAI Developers][1])
* Claude：接入 `claude -p --output-format stream-json` 并做 best-effort usage 提取([Claude Code][2])
* quota exhausted 识别 → 停止调度 + UI 告警

---

## 10. 验收标准（最小可验收）

1. 你在网页新增任务后，不进入任何命令行，也能看到任务开始执行、日志实时滚动、最终 DONE/FAILED
2. 同一个 workspace 连续加 5 个任务：严格串行执行
3. 两个不同 workspace：可并行各跑一个任务
4. 任意 runner kill 掉：RUNNING 任务 lease 超时会被回收并可重试
5. Codex 在 `--json` 模式下能入库 usage，并在 Quota 页可见聚合统计([OpenAI Developers][1])
6. 额度耗尽时：任务标记 `FAILED_QUOTA`，调度暂停，UI 顶栏提示（不自动切换）

---

[1]: https://developers.openai.com/codex/noninteractive/ "Non-interactive mode"
[2]: https://code.claude.com/docs/en/cli-reference "CLI reference - Claude Code Docs"
